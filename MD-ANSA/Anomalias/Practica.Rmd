---
title: "Practica"
author: "Ignacio Vellido"
date: "12/9/2020"
output: 
  prettydoc::html_pretty:
    theme: hpstr
    toc: true
    highlight: github
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, results="hold", fig.align="center", 
                      comment=NA, messages=FALSE)

library(ggplot2)   # Gr?ficos
library(fitdistrplus)  # Ajuste de una distribuciÃ³n -> denscomp 
library(reshape)   # melt
library(ggbiplot)  # biplot
library(tidyverse)   
library(outliers)  # Grubbs
library(MVN)       # mvn: Test de normalidad multivariante  
library(CerioliOutlierDetection)  #MCD Hardin Rocke
library(mvoutlier) # corr.plot 
library(DMwR)      # lof
library(cluster)   # PAM
```

```{r include=FALSE}
# M?ster -> Detecci?n de anomal?as
# Juan Carlos Cubero. Universidad de Granada

###########################################################################
# Funciones utilizadas a lo largo del curso
###########################################################################

# rm(list=ls()) 


###########################################################################
# Realiza un plot de todos los registros
# Permite cambiar el color con el que se visualiza un conjunto de registros. 
# Los registros que se muestran con otro color se especifican en el par?metro
# claves.a.mostrar 

plot_2_colores = function (datos, 
                           claves.a.mostrar, 
                           titulo = "",
                           colores = c("black", "red")){
  
  num.datos = nrow(as.matrix(datos))
  seleccionados =  rep(FALSE, num.datos)
  seleccionados[claves.a.mostrar] = TRUE
  colores.a.mostrar = rep(colores[1], num.datos)
  colores.a.mostrar [seleccionados] = colores[2]
  
  plot(datos, col=colores.a.mostrar, main = titulo)
}



###########################################################################
# Funci?n an?loga a son_outliers_IQR, salvo que devuelve un vector
# de claves en vez de un vector de bools

claves_outliers_IQR = function(datos, ind.columna, coef = 1.5){
  columna.datos = datos[,ind.columna]
  son.outliers.IQR = son_outliers_IQR(datos, ind.columna, coef)
  return (which(son.outliers.IQR  == TRUE))
}



###########################################################################
# Calcula los outliers IQR con respecto a una columna 
# Devuelve un vector de bools indicando si el registro i-?simo 
# de datos es o no un outlier IQR con respecto a la columna ind.columna
# coef es 1.5 para los outliers normales y hay que pasarle 3 para los outliers extremos

son_outliers_IQR = function (datos, ind.columna, coef = 1.5){
  columna.datos = datos[,ind.columna]
  cuartil.primero = quantile(columna.datos)[2]  
  #quantile[1] es el m?nimo y quantile[5] el m?ximo.
  cuartil.tercero = quantile(columna.datos)[4] 
  iqr = cuartil.tercero - cuartil.primero
  extremo.superior.outlier = (iqr * coef) + cuartil.tercero
  extremo.inferior.outlier = cuartil.primero - (iqr * coef)
  son.outliers.IQR  = columna.datos > extremo.superior.outlier |
    columna.datos < extremo.inferior.outlier
  return (son.outliers.IQR)
}


###########################################################################
# Calcula los outliers IQR con respecto a ALGUNA columna
# Devuelve un vector de claves indicando si el registro i-?simo 
# de datos es o no un outlier IQR con respecto a ALGUNA columna
# coef es 1.5 para los outliers normales y  3 para los outliers extremos

claves_outliers_IQR_en_alguna_columna = function(datos, coef = 1.5){
  df.clave.columnas = data.frame()
  claves.outliers =  sapply(1:ncol(datos), 
                               function(x) claves_outliers_IQR(datos, x, coef)
  )
  claves.outliers.en.alguna.columna = unlist(claves.outliers)
  return (claves.outliers.en.alguna.columna)
}




#######################################################################
# Devuelve los nombres de aquellas filas especificadas en el par?metro claves
# filas es un vector de bools 

nombres_filas = function (datos, claves) {
  num.claves = length(claves)
  nombres.filas = row.names(as.data.frame(datos))[claves]
  
  return (nombres.filas)
}




#######################################################################
# funci?n base para diag_caja_outliers_IQR y diag_caja

diag_caja_grafico_base = function(datos, indice.columna){
  # Importante: Para que aes busque los par?metros en el ?mbito local, 
  # debe incluirse  environment = environment()
  nombre.columna = colnames(datos)[indice.columna]
  ggboxplot = ggplot(data = as.data.frame(datos), 
                     aes(x=factor(""), 
                         y = datos[,indice.columna]) , 
                     environment = environment()) + 
              xlab(nombre.columna) + ylab("") 
  return (ggboxplot)
}

#######################################################################
# Muestra un diagrama de caja
# Calcula los outliers IQR y los muestra como puntos en rojo en un BoxPlot

diag_caja_outliers_IQR = function (datos, ind.columna, coef.IQR = 1.5){
  # Si quisi?semos l?neas horizontales en los l?mites de las cajas
  # habr?a que a?adir 
  # + stat_boxplot(geom = 'errorbar')   
  
   outliers.IQR = son_outliers_IQR(datos, ind.columna, coef = coef.IQR)
   ggboxplot =  diag_caja_grafico_base(datos, ind.columna) + 
                stat_boxplot(coef = coef.IQR) +
                geom_boxplot(coef = coef.IQR, outlier.colour = "red") 
                # Importante: geom_boxplot debe ir despu?s de stat_boxplot
   
   return (ggboxplot)
}



#######################################################################
# Muestra un diagrama de caja
# Tambi?n muestra las etiquetas de los registros indicados en 
# el par?metro claves.a.mostrar 

diag_caja = function (datos, ind.columna, claves.a.mostrar = c()){
  num.filas = nrow(datos)
  num.claves = length(claves.a.mostrar)
  nombres.filas = vector (mode = "character", length = num.filas)
  nombres.filas = rep("", num.filas)
  nombres.claves = nombres_filas(datos, claves.a.mostrar)

  for (i in num.claves)
    nombres.filas[claves.a.mostrar[i]]  = nombres.claves[i]
  

  ggboxplot = diag_caja_grafico_base(datos, ind.columna) + 
    geom_boxplot(outlier.shape = NA) + # Para que no imprima los outliers IQR calculados dentro del mismo geom_boxplot
    geom_text(aes(label = nombres.filas)) 
  
  return (ggboxplot)
}






#######################################################################
# Muestra de forma conjunta todos los diagramas de caja de las variables de datos
# Para ello, normaliza previamente los datos.
# Tambi?n muestra las etiquetas de los registros indicados en claves.a.mostrar
# Requiere reshape

diag_caja_juntos = function (datos, titulo = "", claves.a.mostrar = c()){  
  # Importante: Para que aes busque los par?metros en el ?mbito local, 
  # debe incluirse  environment = environment()
  
  # Para hacerlo con ggplot, lamentablemente hay que construir antes una tabla 
  # que contenga en cada fila el valor que a cada tupla le da cada variable 
  # -> paquete reshape->melt
  
  # Por ejemplo, si tenemos el siguiente data frame
  
  # datos = data.frame(
  #   A = c(1, 2),
  #   B = c(3, 4)
  # )
  # datos =
  #     A  B
  #     1  3
  #     2  4
  
  # melt(datos) construye esta tabla:
  
  #      variable value
  # 1        A     1
  # 2        A     2
  # 3        B     3
  # 4        B     4
  
  
  nombres.de.filas = nombres_filas (datos, claves.a.mostrar)
  
  datos = scale(datos)
  datos.melted = melt(datos)
  colnames(datos.melted)[2]="Variables"
  colnames(datos.melted)[3]="zscore"
  factor.melted = colnames(datos.melted)[1]
  columna.factor = as.factor(datos.melted[,factor.melted])
  levels(columna.factor)[!levels(columna.factor) %in% nombres.de.filas] = ""  
  
  ggplot(data = datos.melted, 
         aes(x=Variables, y=zscore), 
         environment = environment()) + 
    ggtitle(titulo) + 
    geom_boxplot(outlier.shape = NA) + 
    geom_text(aes(label = columna.factor), size = 3) 
}






#######################################################################
# Muestra un biplot del conjunto de datos
# Se muestran los nombres de los registros indicados en claves.a.mostrar
# El color usado para dichos registros es el segundo del par?metro colores
# El t?tulo para el grupo de dichos registros es el especificado en titulo.grupo.a.mostrar
# El par?metro titulo especifica el t?tulo principal del gr?fico

biplot_2_colores = function (datos, 
                             claves.a.mostrar = c(), 
                             titulo = "",
                             titulo.grupo.a.mostrar = "Outliers",
                             colores = c("black","red")){
  nombres = rownames(datos)
  claves.datos = c(1:nrow(datos))
  son.a.mostrar = claves.datos %in% claves.a.mostrar
  nombres[!son.a.mostrar] = ''

  PCA.model = princomp(scale(datos))
  outlier.shapes = c(".","x") 
  biplot = ggbiplot(PCA.model,
                    obs.scale = 1,
                    var.scale = 1 ,
                    varname.size = 5,
                    groups =  son.a.mostrar,
                    alpha = 1/2) #alpha = 1/10
  biplot = biplot + labs(color = titulo.grupo.a.mostrar)
  biplot = biplot + scale_color_manual(values = colores)
  biplot = biplot + geom_text(label = nombres,
                              stat = "identity",
                              size = 3,
                              hjust=0,
                              vjust=0)
  biplot = biplot + ggtitle(titulo)
}



#######################################################################
# Muestra un biplot de un conjunto de datos diferenciados por color
# El color lo determina la asignaci?n de cada dato a un cluster 
# Las asignaciones de datos a cluster se indican en asignaciones.clustering
# Tambi?n se muestran los outliers cuyas claves vienen indicadas en claves.outliers
 
biplot_outliers_clustering = function(datos, 
                                      titulo = "Outliers por el m?todo de Clustering", 
                                      titulo.color = "Asignaciones Clustering",
                                      titulo.outlier = "Outliers",
                                      asignaciones.clustering,
                                      claves.outliers){
  son.outliers = rep(FALSE, nrow(datos))
  son.outliers[claves.outliers] = TRUE
  
  bip = biplot_colores_formas(datos, 
                              titulo, titulo.color, titulo.outlier,
                              asignaciones.clustering,
                              son.outliers,
                              claves.outliers)
  bip 
}

#######################################################################
# Muestra un biplot del conjunto de datos
# Los datos se muestran diferenciados por color y por forma
# Las asignaciones de cada dato a su color y forma vienen dadas por los vectores
# asignaciones.colores y asignaciones.formas 
# Tambi?n se muestran las etiquetas de los registros indicados
# en el par?metro opcional claves.a.mostrar 

biplot_colores_formas = function (datos, 
                                  titulo, titulo.color = '', titulo.forma = '', 
                                  asignaciones.colores, asignaciones.formas,
                                  claves.a.mostrar = c()){
  PCA.model = princomp(scale(datos))
  
  son.a.mostrar = rep(FALSE, nrow(datos))
  son.a.mostrar[claves.a.mostrar] = TRUE
  nombres.a.mostrar = rownames(datos)
  nombres.a.mostrar[!son.a.mostrar] = ''

  asignaciones.colores = factor(asignaciones.colores)
  asignaciones.formas  = factor(asignaciones.formas)

  
  bip = ggbiplot(PCA.model, obs.scale = 1, var.scale=1 , varname.size = 3, alpha = 0) +              
    geom_point(aes(shape = asignaciones.formas, colour = asignaciones.colores))  +
    labs(shape = titulo.forma) +
    labs(colour = titulo.color) +
    ggtitle(titulo) +
    geom_text(label = nombres.a.mostrar, stat = "identity", size = 3, hjust=0, vjust=0)      
  
  bip
}

#######################################################################
# Calcula las distancias de cada dato al centroide de su cluster
# Las asignaciones de cada dato a su cluster se indican en asignaciones.clustering
# Cada centroide es una fila del data frame datos.centroides.normalizados

distancias_a_centroides = function (datos.normalizados, 
                                    asignaciones.clustering, 
                                    datos.centroides.normalizados){
  
  sqrt(rowSums(   (datos.normalizados 
                   - 
                   datos.centroides.normalizados[asignaciones.clustering,])^2  ))
}


#######################################################################
# Revierte la funci?n de normalizaci?n (z-score)

desnormaliza = function(datos, filas.normalizadas){
  medias        = colMeans(datos)
  desviaciones  = apply(datos, 2, sd , na.rm = TRUE)
  
  filas.desnormalizadas  = sweep(filas.normalizadas, 2, desviaciones, "*")
  filas.desnormalizadas  = sweep(filas.desnormalizadas, 2, medias, "+")
  
  filas.desnormalizadas 
}




top_clustering_outliers = function(datos.norm, 
                                   asignaciones.clustering, 
                                   datos.centroides.norm, 
                                   num.outliers){
  
  dist_centroides = distancias_a_centroides (datos.norm, 
                                             asignaciones.clustering, 
                                             datos.centroides.norm)
  
  claves = order(dist_centroides, decreasing=T)[1:num.outliers]
  
  list(distancias = dist_centroides[claves]  , claves = claves)
}
```

# Dataset y SelecciÃ³n de Variables

En este guion usaremos el conjunto de datos __mtcars__ disponible directamente en R. Contiene los datos de un serie de vehÃ­culos. Puede encontrar en Internet una descripciÃ³n completa de dicho dataset. Nosotros describimos aquÃ­ las columnas que serÃ¡n el objetivo de nuestro estudio.

- Variables relativas a las caracterÃ­sticas fÃ­sicas

  - disp (displacement) Nos indica la cilindrada en pulgadas cÃºbicas. En EspaÃ±a, lo normal es referirnos a la cilindrada en centÃ­metros cÃºbicos.

  - hp (horse power) Es la potencia del motor

  - drat (Rear axle ratio) Es la relaciÃ³n del eje trasero. Un valor bajo nos permite unos desarrollos mayores con bajo consumo: es lo habitual en turismos. Un valor alto hace que el coche consuma mÃ¡s, pero permite enviar mÃ¡s fuerza, como por ejemplo en un todo terreno.

  - wt (weight) Peso del vehÃ­culo

- Variables relativas al rendimiento

  - mpg (miles per gallon) Nos indica el consumo del coche. Cuanto mayor sea, mÃ¡s combustible consume.

  - qsec (1/4 mile time) Mide el tiempo necesario para recorrer un cuarto de milla. Es una medida inversa a la aceleraciÃ³n: cuanto mÃ¡s acelere un coche, menor serÃ¡ el valor de qsec .

Para trabajar con dicho conjunto, vamos a construir los siguientes objetos:

  - datos: frame de datos que contendrÃ¡ mtcars
  - datos.num: frame obtenido a partir de datos utilizando sÃ³lo las columnas de tipo numÃ©rico.
  - indice.columna: Ãndice de la columna de datos con la que se quiera trabajar.
  - columna: ContendrÃ¡ la columna de datos correspondiente a indice.columna.
  - nombre.columna: Nombre de la columna correspondiente a indice.columna.

Trabajaremos Ãºnicamente sobre las variables numÃ©ricas. Por lo tanto procedemos de la siguiente forma:

1. Cargamos el conjunto de datos. En nuestro caso usaremos el conjunto de datos mtcars
2. Seleccionamos sÃ³lo las variables numÃ©ricas. Para ello usamos la funciÃ³n is.numeric. Aplicada sobre una columna, nos dice si 3. todos sus valores son numÃ©ricos. Por ejemplo, para ver si la tercera columna es numÃ©rica, pondrÃ­amos is.numeric(datos[, 3])
4. Vemos los valores que toman dichas variables y eliminamos aquellas que sean ordinales o con pocos valores distintos
5. Eliminamos tambiÃ©n aquellos registros que tienen algÃºn valor nulo en alguna columna. En aquellos casos en los que tenga sentido hacerlo, se puede aplicar un procedimiento de imputaciÃ³n de valores en vez de eliminar dichos registros.

Cargamos el conjunto de datos
```{r}
datos = mtcars
head(datos)
```

ConstruÃ­mos un dataframe con las columnas numÃ©ricas
```{r}
columnas.num = sapply(c(1:ncol(datos)) , function(x) is.numeric(datos[, x]))
columnas.num

datos.num = datos[, columnas.num]
```

Vemos informaciÃ³n sobre cada variable
```{r}
head(datos)

# Medidas estadÃ­sticas
summary(datos)

# Ocurrencias
apply(mpg, 2, table)
```

Puede apreciar que las variables cyl, vs, am, gear, carb tienen muy pocos valores distintos por lo que las eliminamos del estudio.
```{r}
datos.num  = datos.num[,-c(2 , 8:11)]  
head(datos.num)
```

Finalmente, eliminamos todas aquellas filas que tengan algÃºn valor nulo:
```{r}
datos.num = na.omit(datos.num)
```

# DetecciÃ³n de outliers en una dimensiÃ³n
## Outliers IQR

Los mÃ©todos IQR teÃ³ricamente solo se deben aplicar a distribuciones normales, pero tambiÃ©n pueden funcionar si la forma de la distribuciÃ³n no es rara (multimodal, uniforme...).

Mostramos histograma de cada variable
```{r}
par(mfrow = c(2,3))
c(1:ncol(datos.num)) %>% sapply(function(x) hist(datos.num[,x], 
                                                 main="", 
                                                 xlab=names(datos.num)[x]))
```

Comprobamos normalidad con el test de Shapiro
```{r}
# shapiro.test(datos.num[,-1])
# datos.num %>% apply(2, is.numeric)
```

Ninguna variable sigue una distribuciÃ³n __rara__ (quizÃ¡s la variable _disp_ que parece uniforme), asÃ­ que mantenemos todas las columnas.

A falta de mÃ¡s informaciÃ³n, seleccionamos cualquiera de ellas (posteriormente trabajaremos con todas) Por ejemplo, seleccionamos _mpg_ (ya que junto a qsec, drat y hp son las que mÃ¡s se asemejan a una Normal) Establecemos las siguientes variables para reutilizarlas a lo largo de este apartado.

```{r}
indice.columna = 1
columna        = datos.num[, indice.columna]
nombre.columna = names(datos.num) [indice.columna]
```

### ObtenciÃ³n de los outliers IQR

1. En primer lugar debe calcular las siguiente variables:

  - cuartil.primero: Es el primer cuartil
  - cuartil.tercero: Es el tercer cuartil
  - iqr : Distancia intercuartil IQR
  
  Para ello, usamos las siguientes funciones:

  - quantile(columna, x) para obtener los cuartiles: x=0.25 para el primer cuartil, 0.5 para la mediana y 0.75 para el tercero.
  - IQR para obtener la distancia intercuartil (o bien reste directamente el cuartil tercero y el primero)
  
```{r}
cuartil.primero <- quantile(columna, .25, names = F)
cuartil.tercero <- quantile(columna, .75, names = F)
iqr <- IQR(columna)
```

```{r}
cat("Q1: ")
cuartil.primero
cat("\nQ3: ")
cuartil.tercero
cat("\nIQR: ")
iqr
```
  
2. A continuaciÃ³n debe calcular los extremos que delimitan los outliers:

  - extremo.superior.outlier.IQR se calcula como el cuartil tercero mÃ¡s 1.5 veces la distancia intercuartil.
  - extremo.inferior.outlier.IQR se calcula como el cuartil primero menos 1.5 veces 1.5 la distancia intercuartil.
  - extremo.superior.outlier.IQR.extremo se calcula como el cuartil tercero mÃ¡s 3 veces la distancia intercuartil.
  - extremo.inferior.outlier.IQR.extremo se calcula como el cuartil primero menos 3 veces la distancia intercuartil.

```{r}
extremo.superior.outlier.IQR <- cuartil.tercero + 1.5 * iqr
extremo.inferior.outlier.IQR <- cuartil.primero - 1.5 * iqr
extremo.superior.outlier.IQR.extremo <- cuartil.tercero + 3 * iqr
extremo.inferior.outlier.IQR.extremo <- cuartil.primero - 3 * iqr
```

```{r}
extremo.superior.outlier.IQR
extremo.inferior.outlier.IQR
extremo.superior.outlier.IQR.extremo
extremo.inferior.outlier.IQR.extremo
```


3. Finalmente, construya sendos vectores de valores lÃ³gicos TRUE/FALSE que nos dicen si cada registro es o no un outlier con respecto a la columna fijada:

  - son.outliers.IQR
  - son.outliers.IQR.extremos

Para ello, basta comparar con el operador relacional > o el operador relacional < la columna con alguno de los valores extremos anteriores (El operador lÃ³gico que debe usar es |)

```{r}
son.outliers.IQR <- columna < extremo.inferior.outlier.IQR | columna > extremo.superior.outlier.IQR
son.outliers.IQR.extremos <- columna < extremo.inferior.outlier.IQR.extremo | columna > extremo.superior.outlier.IQR.extremo
```

```{r}
head(son.outliers.IQR)
head(son.outliers.IQR.extremos)
sum(son.outliers.IQR)
sum(son.outliers.IQR.extremos)
```

### Ãndices y valores de los outliers IQR
```{r}
claves.outliers.IQR <- which(son.outliers.IQR)
df.outliers.IQR <- datos.num[claves.outliers.IQR,]
nombres.outliers.IQR <- row.names(df.outliers.IQR) 
valores.outliers.IQR <- columna[claves.outliers.IQR]

claves.outliers.IQR.extremos <- which(son.outliers.IQR.extremos)
df.outliers.IQR.extremos <- datos.num[claves.outliers.IQR.extremos,]
nombres.outliers.IQR.extremos <- row.names(df.outliers.IQR.extremos) 
valores.outliers.IQR.extremos <- columna[claves.outliers.IQR.extremos]
```

```{r}
claves.outliers.IQR
df.outliers.IQR
nombres.outliers.IQR
valores.outliers.IQR
```


```{r}
claves.outliers.IQR.extremos
df.outliers.IQR.extremos
nombres.outliers.IQR.extremos
valores.outliers.IQR.extremos
```

### CÃ³mputo de los outliers IQR con funciones

ELIMINAR LO DE ARRIBA PARA LA MEMORIA (o incluÃ­rlo como subapartado)

```{r}
son.outliers.IQR     = son_outliers_IQR(datos.num, indice.columna)
head(son.outliers.IQR)

claves.outliers.IQR  = claves_outliers_IQR(datos.num, indice.columna)
claves.outliers.IQR

son.outliers.IQR.extremos    = son_outliers_IQR(datos.num, indice.columna, 3)
head(son.outliers.IQR.extremos)

claves.outliers.IQR.extremos = claves_outliers_IQR(datos.num, indice.columna, 3)
claves.outliers.IQR.extremos
```

### DesviaciÃ³n de los outliers con respecto a la media de la columna

Si partimos de una variable X cuya distribuciÃ³n no es normal, el mÃ©todo de z-score no obtiene una N(0,1), pero si la distribuciÃ³n de X no es demasiado rara, los datos que asÃ­ obtengamos nos darÃ¡n informaciÃ³n Ãºtil sobre si los registros son usuales o no. Para ilustrarlo, apliquemos el mÃ©todo z-score a la variable mpg. Para ello, usamos la funciÃ³n scale:

```{r}
datos.num.norm = scale(datos.num)
head(datos.num.norm)

columna.norm   = datos.num.norm[, indice.columna]
```
Para ver los valores normalizados de los outliers, construya la la variable valores.outliers.IQR.norm. Para ello, debe usar la variable columna.norm junto con son.outliers.IQR (o bien claves.outliers.IQR). Le debe salir lo siguiente:
```{r}
valores.outliers.IQR.norm <- columna.norm[claves.outliers.IQR]

valores.outliers.IQR.norm
```

Vamos a ver ahora el comportamiento de los outliers en la columna seleccionada con respecto al resto de columnas. Para ello, basta con seleccionar los datos correspondientes del conjunto de datos normalizado. En nuestro caso, sÃ³lo tenemos un outlier IQR en la columna seleccionada. Nos debe salir lo siguiente:

```{r}
datos.num.norm.outliers.IQR <- datos.num.norm[claves.outliers.IQR,]

datos.num.norm.outliers.IQR
```
Podemos apreciar que el Toyota Corolla no tiene valores excesivamente grandes o pequeÃ±os en el resto de columnas (distintas de mpg)

### GrÃ¡fico

Mostramos en un grÃ¡fico los valores de los registros. Usaremos el color rojo para mostrar lo outliers. Para ello, llame a la siguiente funciÃ³n:
```{r}
plot_2_colores(datos.num.norm, claves.outliers.IQR)
```

```{r}
plot_2_colores(datos.num.norm, claves.outliers.IQR.extremos)
```

### Diagrama de cajas

Otro anÃ¡lisis exploratorio de los datos nos lo da los diagramas de cajas. Vamos a usar la funciÃ³n geom_boxplot definida en el paquete ggplot. En vez de usarla directamente, llamamos a la siguiente funciÃ³n (que llama internamente a geom_boxplot), disponible en el fichero

```{r}
diag_caja_outliers_IQR(datos.num.norm, 1)
```

Esta funciÃ³n se ha construido para mostrar un diagrama de cajas genÃ©rico. El diagrama tambiÃ©n muestra las etiquetas de los registros cuyos Ã­ndices se indican en el parÃ¡metro claves.a.mostrar. En nuestro caso, le pasamos como parÃ¡metro el vector que ya habÃ­a construido anteriormente con los Ã­ndices de los outliers IQR, es decir, el vector claves.outliers.IQR ( pero podrÃ­a pasarle cualquier otro vector de Ã­ndices). Nos debe salir lo siguiente:

```{r}
diag_caja(datos.num.norm, 1, claves.outliers.IQR)
```

Al igual que hicimos en el apartado anterior, vamos a analizar los valores que un outlier (con respecto a una columna seleccionada) toma en el resto de columnas. Para ello, vamos a mostrar de forma conjunta los diagramas de cajas de varias variables. Llamamos a la funciÃ³n diag_caja_juntos, disponible en el fichero OutliersFunciones_byCubero.R
```{r}
diag_caja_juntos(datos.num, "Outliers", claves.outliers.IQR)
```

Tal y como habÃ­amos analizado anteriormente, el Toyota Corolla (que es un outlier IQR con respecto a mpg) no tiene valores anormales en el resto de columnas (aunque tal vez con la excepciÃ³n de la variable disp).

## Test de hipÃ³tesis